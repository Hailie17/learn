5天+2天模拟面试+2-3天+5(+-)天
实训室30天左右，老师全程指导找工作...
出勤+项目提交+老师的安排+指导的安排（录音）
1.满勤+项目提交+完成安排+听从指挥 -》 没有就业《- 采取必要措施
2.出勤差+项目不提交+不停安排+没有录音 -》 找不到工作

一、BFC
    1.概念：块级格式化上下文，是一种盒模型布局的CSS渲染模式；
        也就是说它是一个独立的渲染区域或者是一个独立的容器
        就是一个有着自己规则的区域，不受外界的影响
    2.w3c定义的规范
        1.浮动元素、绝对定位元素，不是块级盒子的块级容器(inline-block,table-cell，table-caption),
            还有overflow的值不是visible的块级盒子，都是BFC
        2.在BFC里，从顶部开始垂直排列，两个盒子中的距离是margin决定的，在同一个BFC里
            两个相邻的盒子的垂直外边距会发生重叠
        3.在BFC里，每个盒子左边缘会紧靠容器的左边缘，在浮动里也是如粗，除非你在内部又创建
            了BFC
    3.BFC的渲染
        1.BFC内部不会和浮动元素的容器发生重叠（解决浮动时文字环绕）
        2.BFC是独立容器，内外元素互不影响（解决外边距重叠）
        3.BFC内垂直方向距离由margin决定，同一个BFC区域，相邻容器依然会重叠
        4.如果要计算BFC的高度，那么浮动元素也会参与计算（清楚浮动！！！）
    4.如何创建BFC
        // 1.浮动元素：float:left/right(造成父元素高度塌陷)
        2.定位：absolute/fixed
        3.display:inline-block(把原来元素转为了行内块元素，高度依然会塌陷)
            flex,table,table-cell,...
            [注意：flow-root],存在兼容性问题吗，用的也不多
        4.overflow：它的值不是visible,就可以创建BFC
            hidden(会让溢出的内容不显示)，auto,scroll

    5.BFC的使用
        1.清楚浮动
        2.解决外边距重叠

二、JavaScript的面试题
    2.1 预编译 -> 作用域 -> 闭包
        https://zhuanlan.zhihu.com/p/483283900
        JS执行顺序
            1.检查通篇代码是否有报错
            2.预编译
            3.JS单线程，从上往下，只能解释一行，执行一行
        函数提升和变量提升
            fun()
            function fun(){
                console.log(12345)
            }
            函数声明会发生提升，并且它是整体提升
            console.log( a ) //Undefined
            var a = 111
            console.log( a )
            console.log( a ) //Undefined
            var a
            变量提升，只提升变量名，不会赋值var a = 1(1.声明变量，2.赋值)
        暗示全局变量（imply global variable）
            a = 1
            console.log( a )
            console.log( window.a )
            var b = 2
            console.log( b )
            console.log( window.b )
            // window = {
            //     a:1
            // }
        预编译：
            执行代码前，会先预编译 -> “函数执行期上下文”（局部作用域）
            函数执行期上下文：Activation Object 简称AO 活跃对象
                第一步：找函数的形参和变量声明
                第二步：把实参赋值给形参
                第三步：找函数声明，并赋值函数体（函数体内部代码不执行），
                第四部：执行代码
                【预编译阶段执行过的代码，在函数执行期间，不会再次执行，只会执行预编译期间没执行的代码】
            在函数产生之前就生成一个全局作用域。
            全局执行期上下文 global Object  简称：GO
            在全局代码执行前，就会创建GO，它和AO差不多，只不过全局没有形参
                第一步：寻找变量声明
                第二步：寻找函数声明，并赋值函数体(内部代码不执行)
                第三步：执行代码